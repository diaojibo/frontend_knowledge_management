## js作用域链
JS中的作用域，大家都知道的，分为全局作用域和局部作用域，没有块级作用域

**除了Global Scope，只有function可以创建新作用域（Function Scope）。**不过这已经是老黄历了，ES6引入了Block Scope。

在js中，函数也是对象，在函数这个对象内，有一个[[scope]]属性，这个属性的指就是函数被创建的作用域中对象的集合，其实即是函数(闭包)的上下文。直观一点，就是假如定义下面这个函数：


``` javascript
function add(num1,num2) {
    var sum = num1 + num2;
    return sum;
}
```

定义这个函数的时候就会在函数内的[[scope]]属性里，传递一个global对象。

![](image/scope_chain1.jpg)

这就完成了函数声明的初始化，传入全局对象。

这只是声明函数被创建未执行的时候。

但是如若每个函数被创建出来执行，如
``` javascript
var total = add(5,10);
```

执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。

这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。新的作用域链如下图所示
![](image/scope_chain2.jpg)

### 尝试总结
总之就是函数在声明时，会创建一个Variable Object[上文的全局对象]对象，里面有定义时写明的声明变量，和形参。

而函数在创建执行时，会生成一个上下文对象，即是活动对象AO，里面包含有上下文的变量定义，这些都传递进函数对象的[[scope]]里，方便之后进行变量查表。

一般自己的活动对象会放在作用域链中的第一个位置，上一个位置是上一个调用函数的活动对象，一直到全局对象。如果检索变量，这些对象里都没有，那么undefined。