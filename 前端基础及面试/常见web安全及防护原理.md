## 常见web安全及防护原理

### sql注入
就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

最简单的比如在查询后面 ?id=1'or 1=1

这样可以再select的时候把全表都检索出来

总的来说有以下几点：

```

    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。

    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。

    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。

    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。
```

### XSS
<a>http://www.freebuf.com/articles/web/40520.html</a>

XSS的全称是Cross Site Scripting，意思是跨站脚本.这第一个单词是Cross，为什么缩写成X呢？因为CSS是层叠样式表的缩写（Cascading Style Sheets）的缩写，同时Cross发音和X相似，为了避免混淆用X来代替,缩写成XSS。

在没有过滤字符的情况下，只需要保持完整无错的脚本标记即可触发XSS，假如我们在某个资料表单提交内容,表单提交内容就是某个标记属性所赋的值，我们可以构造如下值来闭和标记来构造完整无错的脚本标记，
``` html

"><script>alert(''XSS'');</script><"

```

如若是直接将表单输入的字符串直接嵌入到html里的话，那就会执行js脚本。

不仅仅是script标签里，如果构造巧妙，在标签属性里也可以通过构造闭合来执行js代码。

**“xss就是在页面执行你想要的js”**

比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取`cookie`中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。

#### 防范
首先代码里对用户输入的地方和变量都需要仔细检查长度和对`”<”,”>”,”;”,”’”`等字符做过滤；其次任何内容写到页面之前都必须加以`encode`，避免不小心把`html tag` 弄出来。这一个层面做好，至少可以堵住超过一半的`XSS` 攻击。


首先，避免直接在`cookie` 中泄露用户隐私，例如email、密码等等。


其次，通过使`cookie` 和系统`ip` 绑定来降低`cookie` 泄露后的危险。这样攻击者得到的`cookie` 没有实际价值，不可能拿来重放。


如果网站不需要再浏览器端对`cookie` 进行操作，可以在`Set-Cookie` 末尾加上`HttpOnly` 来防止`javascript` 代码直接获取`cookie` 。


尽量采用`POST` 而非`GET` 提交表单(因为ajax无法跨域，不能用js提交post数据到一个地方，比如我在自己某个网站山xss了一段js，是添加一个用户进某个数据库的，引诱那个数据库的管理员来登录这个网站，那么假如这个管理员已经在浏览器登录了后台，那这时他一登那个有xss的网站，js会执行并插入一条数据到那个已登录的后台，又因为此时有cookie有权限，所以能成功。如若那个后台是用post方式提交的话，ajax则不能提交请求过去插入数据[伪造form其实也可以]，不能跨域)

#### 其他
>XSS与CSRF有什么区别吗？

`XSS`是获取信息，不需要提前知道其他用户页面的代码和数据包。`CSRF`是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。


要完成一次`CSRF`攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。

在不登出A的情况下，访问危险网站B。
```


>CSRF的防御

- 服务端的`CSRF`方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。

- 通过验证码的方法